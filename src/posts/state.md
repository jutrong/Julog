---
date: "2023-12-23"
title: "리액트와 상태 관리 라이브러리 비교분석"
thumbnail: "https://plus.unsplash.com/premium_photo-1684262423213-30b0fdc3d513?w=900&auto=format&fit=crop&q=60&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MXx8Z2xvYmFsfGVufDB8fDB8fHww"
categories: "State"
summary: "개발할 때 이야기하는 상태는 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미한다."
---

## 상태관리는 왜 필요한가?

### 상태가 무엇인가 ?

개발할 때 이야기하는 상태는 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미한다.

### 웹 애플리케이션에서 상태로 분류될 수 있는 것들

#### UI : 상호 작용이 가능한 모든 요소의 현재 값 : 다크/라이트 모드, 라이도를 비롯한 각종 Input, 알림창의 노출 여부 등

#### URL : 브라우저에서 관리되고 있는 상태값, 이 상태는 사용자의 라우팅에 따라 변경된다.

#### 폼(form) : 로딩중인지, 현재 제출됐는지, 접근이 불가능한지, 값이 유효한지 등 모두가 상태로 관리된다.

#### 서버에서 가져온 값 : 서버로 요청을 통해 가져온 값도 상태

웹 서비스에서 점차 다양한 기능이 제곰됨에 따라 웹 내부에서 관리해야 할 상태도 점차 비례해서 증가하고 있다.

## 시장 지배자 Redux 등장

리덕스는 하나의 상태 객체를 스토어에 저장해 두고, 이 객체를 업데이트하는 작업을 디스패치해 업데이트를 수행한다.
리덕스의 등장은 리액트 생태계에 많은 영향을 미치게 됐다. 하나으 ㅣ글로벌 상태 객체를 통해 이 상태를 하위 컴포넌트에 전파할 수 있기 때문에 props drilling을 해결할 수 있고, 스토어가 필요한 컴포넌트라면 단지 connect만 쓰면 스토어에 바로 접근할 수 있다.
그렇다고 리덕스가 마냥 편하기만 한 것은 아니었다.
하고자 하는 일에 비해 보일러플레이트가 너무 많다는 비판의 목소리가 있었다.

## Context API

단순한 레벨의 컴포넌트라면 한 두 단계쯤 props를 넘기는 것은 괜찮았지만 자식 컴포넌트의 깊이가 깊어질수록 props가 컴포넌트를 관통해 버리는 현상이 발생했다. 리덕스를 사용해도 되지만 단순히 상태를 참조하고 싶을 뿐인데 준비해야 하는 보일러플레이트도 부담스러웠다. 이는 번거로울 뿐만 아니라 컴포넌트를 설계할 때 커다란 제약으로 작용했다.

context api는 props로 상태를 넘겨주지 않더라도 원하는 곳에서 Context Provider가 주입하는 상태를 사용할 수 있게 되었다.
그러나 Context API는 상태 관리가 아닌 주입을 도와주는 기능이며, 렌더링을 막아주는 기능 또한 존재하지 않으니 사용할 때 주의가 필요하다. \

## React Query와 SWR

훅과 state의 등장으로 이전에는 볼 수 없던 방식의 상태 관리가 등장한다.
바로 react-query와 SWR이다.

두 라이브러리는 모두 외부에서 데이터를 불러오는 fetch를 관리하는 데 특화된 라이브러리지만, api호출에 대한 상태를 관리하고 있기 때문에 HTTP 요청에 특화된 상태 관리 라이브러리라 볼 수 있다.

## 가장 기본적인 방법 : useState와 useReducer

useState의 등장으로 리액트에서는 여러 컴포넌트에 걸쳐 손쉽게 동일한 인터페이스의 상태를 생성하고 관리할 수 있게 되었다.

useState와 useReducer를 기반으로 하는 사용자 지정 훅의 한계는 명확하다. 훅을 사용할 때마다 컴포넌트별로 초기화되므로 컴포넌트에 따라 서로 다른 상태를 가질 수 밖에 없다. 결론적으로 컴포넌트별로 상태의 파편화를 만들어 버린다. 이렇게 기본적인 useState를 기반으로 한 상태를 지역상태라고 하며, 이 지역 상태는 해당 컴포넌트 내에서만 유효하다는 한계가 있다.

## 상태 관리 라이브러리가 어떤 식으로 동작하는가?

- useState, useReducer가 가지고 있는 한계, 컴포넌트 내부에서만 사용할 수 있는 지역 상태라는 점을 극복하기 위해 외부 어딘가에 상태를 둔다.
  이는 컴포넌트의 최상단 내지는 상태가 필요한 부모가 될 수도 있고, 혹은 격리된 자바스크립트 스코프 어딘가일 수도 있다.
- 이 외부의 상태 변경을 각자의 방식으로 감지해 컴포넌트의 렌더링을 일으킨다.

## 상태 관리 라이브러리 살펴보기

Recoil과 Jotai는 context와 Provider, 그리고 훅을 기반으로 가능한 작은 상태를 효율적으로 관리하는데 초점을 맞추고 있다. 그리고 Zustand는 리덕스와 비슷하게 하나의 큰 스토어를 기반으로 상태를 관리하는 라이브러리다.
Recoil과 Jotai와는 다르게 이 하나의 큰 스토어는 Context가 아니라 스토어가 가지는 클로저를 기반으로 생성되며, 이 스토어의 상태가 변경되면 이 상태를 구독하고 있는 컴포넌트에 전파해 리렌더링을 알리는 방식이다.

### 페이스북이 만든 Recoil

리액트에서 훅의 개념으로 상태 관리를 시작한 최초의 라이브러리 중 하나이며, 최소 상태 개념인 Atom을 처음 리액트 생태계에서 선보이기도 했다.
1.0.0이 배포되지 않아 많은 개발자로 하여금 실제 운영되고 있는 서비스에 Recoil설치를 머뭇거리게 하고 있다.
![](https://velog.velcdn.com/images/jutrong/post/0998d018-f210-41c4-88be-2950319d1ba9/image.png)

애플리케이션의 최상단에 <RecoilRoot/>를 선언해 하나의 스토어를 만들고, atom이라는 상태 단위를 <RecoilRoot/>에서 만든 스토어에 등록한다.
atom은 Recoil에서 관리하는 작은 상태 단위이며, 각 값은 고유한 값인 key를 바탕으로 구별된다. 그리고 컴포넌트는 Recoil에서 제공하는 훅을 통해 atom의 상태 변화를 구독하고, 값이 변경되면 forceUpdate 같은 기법을 통해 리렌더링을 실행해 최신 atom 값을 가져오게 된다.

selector를 필두로 다양한 비동기 작업을 지원하는 API를 제공하고 있기 때문에 리덕스와 달리 redux-saga, redux-thunk 등 추가적인 미들웨어를 사용하지 않더라도 비동기 작업을 수월하게 처리할 수 있다.

한 가지 불확신한 점을 정식 버전인 1.0.0이 출시가 안되었다는 점이다.
안정적인 서비스를 만들고자 하는 개발자들에게 선뜻 채택하기 어렵게 만드는 큰 걸림돌이다.

### Recoil에서 영감 받은 그러나 조금 더 유연한 Jutai

리코일의 atom모델에 영감을 받아 만들어진 상태 관리 라이브러리이다.
리액트 Context의 문제점인 불필요한 리렌더링이 일어난다는 문제를 해결하고자 설계돼 있으며, 추가적으로 개발자들이 메모이제이션이나 최적화를 거치지 않아도 리렌더링이 발생되지 않도록 설계돼 있다.

Recoil에서 많은 영감을 받은 만큼 유사한 면이 많아 보임과 동시에 리코일이 가지고 있는 몇 가지 한계점을 극복하기 위한 노력이 엿보인다.

recoil의 atom 개념을 도입하면서도 API가 간결하다는 점을 꼽을 수 있다. Recoil의 atom에서는 각 상태값이 모두 별도의 키를 필요로 하기 때문에 이 키를 별도로 관리해야 하는데, Jotai는 이러한 부분을 추상화해 사용자가 키를 관리할 필요가 없다. Jotai가 별도의 문자열 키가 없이도 각 값들을 관리할 수 있는 것은 객체의 참조를 통해 값을 관리하기 때문이다.

Jotai에서는 selector가 없이도 atom만으로 atom 값에서 또 다른 파생된 상태를 만들 수 있다.

리코일 대비 여러 가지 장점으로 인해 리코일의 atom 형태의 상태 관리를 선호하지만, 아직 정식 버전이 출시되지 않아 사용이 망설여지는 많은 개발자들이 Jotai를 채택해 개발하고 있다.

### 작고 빠르며 확장에도 유연한 Zustand

하나의 스토어를 중앙 집중형으로 활용해 이 스토어 내부에서 상태를 관리한다.

Zunstand는 특별히 많은 코드를 작성하지 않아도 빠르게 스토어를 만들고 사용할 수 있다는 큰 장점이 있다. 스토어를 만들고 이 스토어에 파생된 값을 만드는 데 단 몇 줄의 코드면 충분하다. 이는 리덕스 대비 확실히 구별되는 특징으로 볼 수 있으며, 간단하고 빠르게 상태를 정의할 수 있어 상태를 관리하는 입장에서 한결 가볍고 편리하다.

또한 Zustand는 리덕스와 마찬가지로 미들웨어를 지원한다. 스토어 데이터를 영구히 보존할 수 있는 persist, 복잡한 객체를 관리하기 쉽게 도와주는 immer, 리덕스와 함께 사용할 수 있는 리덕스 미들웨어 등 여러 가지 미들웨어를 제공해 필요한 미들웨어를 사용할 수 있게 도와준다.

## 결론

![](https://velog.velcdn.com/images/jutrong/post/72b62a0c-9eac-41d4-bcd9-c846a0be1650/image.png)
각 라이브러리별로 특징을 잘 파악하고, 현재 애플리케이션의 상황과 철학에 맞는 상태관리 라이브러리를 적절하게 선택해 사용한다면 효율적인 애플리케이션을 만드는 데 도움이 될 것이다.

npm에서 제공하는 모든 라이브러리와 마찬가지로 메인테이너가 많고 다운로드가 활발하며 이슈가 관리가 잘되고 있는 라이브러리를 선택하는 것이 좋다.
